# P4 Tutorials Youtube.

### PISA : Protocol Independent Switch Architecture.
* Contains Programmable Parser, Match action Pipeline, Deparser.
* Packet is parsed into individual headers. Headers can be used for matching and actions. 

### P4 Language Elements.
* Parser
* Controls
* Expressions
* Data types
* Arch Description
* Extern Libraries

**P4 Target** : Embodiment of specific hardware implementation.<br>
**P4 Arch** : Interface to program a target.

Community gives language and core library. Vendor gives extern libraries and Arch def. The V1model is implemented on top of bmv2 simple switch. Metadata varies across arch implementation.

### Data Types 
* bit<n>
* int<n>
* header :  bit alignment
* struct : no bit alignment
* typedef

### P4 Program Template

```
#include<core.p4>
#include<v1model.p4>

struct metadata{}

struct headers{
    ethernet_t ethernet;
    ipv4_t ipv4;
}

parser MyParser(packet_in packet,
                out headers hdr,
                inout metadata meta,
                inout standard_metadata_t smeta){
}

control myVerifyChecksum(in headers hdr,
                        inout metadat meta){
}

control myIngress(in headers hdr,
                inout metadat meta
                inout standard_metadata_t smeta){
}

control myEgress(in headers hdr,
                inout metadat meta
                inout standard_metadata_t smeta){
}

control mycomputeCheckSum(in headers hdr,
                        inout metadat meta){
}

control myDeparser(inout headers hdr,
                    inout metadata meta){
}

V1Switch(
    MyParser();
    myVerifyChecksum();
    myIngress();
    myEgress();
    mycomputeCheckSum();
    myDeparser();
    main;
)

```
### P4 Parsers
They map packets into headers and metadata. Every state has start, accept and reject.
```
parser MyParser(packet_in packet,
                out headers hdrs,
                inout metadata meta,
                inout standard_meta std_meta){
    state start{
        packet.extact(hdr.ethernet);
            transition accept;
        }
    
    state parser_ethernet{
        packet.extract(hdr.ethernet);
        transition select(hdr.ethernet.type){
            0x800 : parse_ipv4;
            default : accept;
        }
    }
}

```

### P4 Simple Actions
Similar to C functions they are declared inside or outside control. They have type and directions as parameters.

```
control myEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata std_meta){
                
    action swap_action(inout bit<48> src, inout bit<48> dst){
        bit<48> tmp = src;
        src = dst;
        dst = tmp;
    }

    apply{
        swap_action();
    }
}
```

### P4 table.
Can define table that contains actions based on keys.
Supported match kind for keys are exact, lpm, ternary or selector.
```
table ipv4_lpm{
    key = {
        hdr.ipv4.dstAddr : lpm;
    }
    actions = {
        ipv4_forward;
        drop;
        NoAction;
    }
    size = 1024;
    default_action = NoAction();
}

```

### Applying tables in Controls

```
control MyEgress(inout headers hdr,
                inout metadata meta,
                inout standard_metadata std_meta){
    action swap_mac(inout bit<48> src, inout bit<48> dst){
        bit<48> temp = scr;
        src = dst;
        dst = temp;
    }
    table ipv4_lpm{

    }

    apply{
        swap_mac();
        ipv4_lpm.apply();
    }
}
```

### Operations on headers
```
* hdr.setValid()
* hdr.setInvalid()
* hdr.isValid()

* hdr.next
* hdr.last
* hdr.lastIndex

* hdr[i]
* hdr.size
* hdr.push_front
* hdr.pop_front
```
### P4 Deparser
Assembling packet from header. This is expressed as another control function.

```
control myDeparser(packet_out packet,
                    in header hdr){

    apply{
        packet.emit(hdr.ethernet);
        packet.emit(hdr.ipv4);
    }

}
```

Stateless Object (Reintialised for each object)
* Variables.
* packet headers.

Stateful Object (Keep their state between packets)
* Tables
* Externs
* Counters
* Meter
* Register.

# P4_16 Lang Spec.


P4 programs are not expected to be portable across different architecture. However, P4 programs should be portable across all targets that faithfully implement corresponding model.

## Preprocessing

* #define
* #undef
* #if #else #endif #ifdef #ifndef #elif
* #include

Use #include <filename> or #include "filename"

## Comments

* Single line : //
* Multiline : /*  */
* Javadoc-style comment : /** */


## Integer Literal
* 0x or 0X  : hexadecimal
* 0b or 0B  : binary 
* 0d or 0D  : decimal - default
* 0o or 0O  : octal


32w255  : 32 bit wide with value 255 
32s255  : 32 bit wide signed value 255

## L value
They appear on the left hand side of an assignment operation. 'out' or 'inout' arguments. 

header, header stack or slice.

## Naming convention    
* built-in type : lowercase
* User defined : Capitalized, IPv4Address.
* type variables : uppercase, parser P<H, IH> ()
* constants : Uppercase.
* errors and enum : camel-case, PacketTooShort


## Copy in/ Copy out
* **in** parameters are read-only. Initialized by copying the value of corresponding argument.

* **out** parameter must be l-value. Value of parameter is copied to corresponding storage location.

* extern objects and compile-time constants can only be pased as directionless param.

* all constructor parameters must be directionless.


## @optional
for optional arguments. <br>
package switch(pipeline first, @optional pipeline second);

## Name resolution
Prefix a dot with identifier to get top-level namespace.

bit<1> x = 0;
control c(){
    bit<1> x = 0;
    x = 1;  // local
    .x = 1;   //global
}

## Data types 
P4 is statically-typed language. Programs that do not pass type checker are considered invalid and rejecetd by compiler.

* built-in type :
    bool, error, bit, int, string, bit< integer >, int< integer >, varbit
* derived type : enum, header, header stacks, struct, header_union, tuple, extern, parser, control, package.


enum Suits{heart, club, spade, diamonds} <br>
each header has a validity bit. isValid(), setValid(), setInValid().
<br>
header stack represents an array of headers.

header mpls_h{
    bit<8> f1;
}
mpls[10] mpls;

<br> ` tuple<t1, t2, ..., tn> `


* Parser type declaration : should have atleast one arg of packet_in.

` parser P<H>(packet_in b, out H hdr, out Counter counters);`


## Expressions

* In && and || second operand is evaluated only if necessary.

* e1 ? e2 : e3.
* Left to right.
* error type only supports == and != comparisions.


Mask  : &&& ; a &&& b where each 0 bit of mask is don't care and 1 is what we take.

## Initialize with default values

Left value can be initialized automatically with suitbale type using ` ... ` 

` struct S{
    bit<8> b8; bool b;
}
S s1 = ...;
`

## Statements
Every statement must end with a semicolon.
May appear within parser states, control blocks or action.

switch statements are only supported in control blocks.

* block statement {}, 
* return statement, not allowed in parser.
* conditional statement.
* switch statement.
* switch with action_run : expression must be of t.apply().action_run and switch labels must be name of actions of table t or default.<br>
` switch(t.apply().action_run){
    action1: 
    action2:
} `


## Parameterization
Two set of paraemeters : parameterList and optConstructParam

constructor parameters must be compile-time constant.

`parser GenericParser(packet_in b, out Packet_header p)(bool udpSupport){....}
GenericParser(false) topParser;`

## Deparsing
Inverse of parsing or packet construction. It is done in a control block that has at least one parameter of type packet_out.


## Architecture Description
Arch description must be provided by target manufacture with atleast one declaration of the package which should be instantiated by the user to construct the program.

`parser Parser<IH> (packet_in p, out IH inputHdr);control IPipe<IH,OH,T>(in IH inputHdr, out OH outputHdr, out T toEgress); control EPipe<IH,OH,T>(in IH inputHdr, out OH outputHdr, in T fromIngress);`


## Packet Parsing

P4 parser has one start state and two final states : accept and reject. Start was part of parser but accept and reject are logically outside of the parser.

* No two states to be defined with same name.
* No control block within the parser.
* No definition of accept and reject states.

### Parser states
Consists of sequence of statements, method calls and transition to states.

### Select Expressions
Select expression evaluates to a state. Keys should match to the expressions.
`select(e) {
key1 : val1; 
key2 : val2;
_ : default}`

### Verify 
simple form of error handling. verify can only be invoked within a parser. 
`extern void verify(in bool condition, in error err);`

### Data extraction
extract method to invoke information from packet. For fixed width `extract(hdr)` and for variable length `extract(hdr,fieldsize32bit)`

### LookAhead
method by packet_in to evaluate set of bits from input packet without moving nextBitIndex pointer. 
`b.lookahead<T>()`

### Subparser 
To invoke services of other parser as a routine.

## Control Blocks
P4 parsers are responsible for extracting bits from a packet into headers. These headers can be manipulated and transformed within control blocks.

### Table properties
### Keys
specifies data plane values that should be used to look up an entry. Of form (e:m)
e is value, m is match kind.

There are 3 defined match kinds that p4 supports. exact, lpm, ternary.

If a table has no key property, then it contains no look-up table, just a default actionâ€”i.e., the associated lookup table is always the empty map.

### Actions 
All possible actions should be declared using actions property and action list.
Parameter with direction must be bound in action list.

### Default action
when lookup table does not find match, default action is invoked. Must appear after actions.

### Entries
Table entries are typically installed by control plane. They can be initialized at compile-time as well.
Table entries are const, cannot be modified by control plane.

Tables can be invoked by using apply() method or using action_run.

`if(){tabel.apply(); } `

`switch(table.apply().action_run){ DropAction: {return;}}`